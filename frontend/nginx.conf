worker_processes 1;

events {
  worker_connections 1024;  # обязательный блок, иначе nginx не стартует
}

http {
  include       mime.types;
  default_type  application/octet-stream;

  # 1. Бэкенд внутри docker‑сети
  upstream backend {
    server backend:5000;  # имя = service‑key из docker‑compose
  }

  server {
    listen 80;

    location / {
      root /usr/share/nginx/html;
    }
    # 2. SPA‑роутинг: все неизвестные пути → index.html
    # location / {
    #   root /usr/share/nginx/html;
    #   index index.html;
    #   try_files $uri $uri/ /index.html;
    # }

    # 3. API‑эндпойнт «/check» → .NET‑контейнер
    location /check {
      proxy_pass http://backend$request_uri;
      proxy_set_header Host $host;  # нужен для редиректов/логов
    }

    # 4. API‑эндпойнт «/auth» → .NET‑контейнер
    location /auth {
      proxy_pass http://backend$request_uri;
      proxy_set_header Host $host;  # нужен для редиректов/логов
    }

    # Проверка JWT‑токена через /auth/validate
    # 5. API‑эндпойнт «/_auth» → http://backend/auth/validate;
    location /_auth {
      internal;                                     # делает location доступным только для внутренних запросов Nginx (нельзя вызвать напрямую из браузера)
      proxy_pass http://backend/auth/validate;      # отправляем запрос к backend (сервис .NET) по эндпойнту /auth/validate
      proxy_set_header Authorization "Bearer $cookie_pet_token";  
                                                    # формируем заголовок Authorization: Bearer <jwt из cookie>
      proxy_pass_request_body off;                  # отключаем пересылку тела запроса (здесь не нужно, потому что это GET)
      proxy_set_header Content-Length "";           # сбрасываем Content-Length (иначе Nginx может передать "0" и backend решит, что тело пустое)
    }

    # Grafana под /grafana/
    location /grafana/ {
      # 1) доступ только для авторизованных пользователей
      auth_request /_auth;                           # делаем внутренний запрос в /_auth, который вернёт 200/401
      auth_request_set $graf_user $upstream_http_x_user; # если backend прислал заголовок X-User, сохраняем его в переменную $graf_user

      # 2) проксируем в контейнер grafana и передаём ей имя пользователя
      proxy_pass http://grafana:3000/;               # прокидываем трафик в сервис grafana (docker-compose service name)
      proxy_set_header Host $host;                   # передаём исходный Host клиента
      proxy_set_header X-Forwarded-Host $host;       # прокидываем оригинальный хост в X-Forwarded-Host
      proxy_set_header X-Forwarded-Proto $scheme;    # прокидываем схему (http/https) в X-Forwarded-Proto
      proxy_set_header X-Forwarded-Prefix /grafana;  # указываем Grafana, что она работает под подпутём /grafana

      # auth proxy: логиним пользователя в Grafana
      proxy_set_header X-WEBAUTH-USER $graf_user;    # передаём имя пользователя в Grafana для proxy-SSO

      # 3) поддержка WebSocket/long-poll
      proxy_http_version 1.1;                        # включаем HTTP/1.1, иначе WS не будут работать
      proxy_set_header Upgrade $http_upgrade;        # поддержка Upgrade для WS
      proxy_set_header Connection "upgrade";         # то же для WS: Connection: upgrade
    }
  }
}
